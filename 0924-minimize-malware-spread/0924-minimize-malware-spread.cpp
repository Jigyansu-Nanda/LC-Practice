#include <bits/stdc++.h>
using namespace::std;

/* ------------------------------------- Debugger ------------------------------------------ */

template<typename A, typename B> std::ostream& operator<<(std::ostream &os, const std::pair<A, B> &p) { return os << '(' << p.first << ", " << p.second << ')'; }
template < typename T_container, typename T = typename std::enable_if < !std::is_same<T_container, std::string>::value, typename T_container::value_type >::type > std::ostream & operator<<(std::ostream &os, const T_container &v) { os << '{'; std::string sep; for (const T &x : v) os << sep << x, sep = ", "; return os << '}'; }

void debug() { std::cout << '\n'; }
template<typename Head, typename... Tail> void debug(Head H, Tail... T) { std::cout << ' ' << H; debug(T...); }

// void print(ListNode* head) {while (head) {cout << head->val << ' '; head = head->next;} cout << '\n';}

#ifdef LOCAL_MACHINE
#include "leetcode.h"
#define debug(...) std::cout << "(" << #__VA_ARGS__ << "):", debug(__VA_ARGS__)
#else
#define debug(...) 42
#define print(...) 42
#endif

/* ----------------------------------------------------------------------------------------- */

struct DSU {
public:
    int components;
    vector<int> Parent, Rank;

    DSU(int n) : components(n), Parent(n), Rank(n, 1) { iota(Parent.begin(), Parent.end(), 0); }

    int find(int x) {
        while (x != Parent[x]) x = Parent[x] = Parent[Parent[x]];
        return x;
    }

    bool merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return false;
        if (Rank[x] > Rank[y]) swap(x, y);
        Parent[x] = y;
        Rank[y] += Rank[x];
        --components;
        return true;
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        DSU dsu(n);
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                if (graph[i][j]) dsu.merge(i, j);
            }
        }
        sort(initial.begin(), initial.end());
        vector<int> initialInfectedNodesInSubgraph(n, 0);
        for (auto &node : initial) initialInfectedNodesInSubgraph[dsu.find(node)]++;
        vector<pair<int, int>> ans;
        for (auto &node : initial) {
            if (initialInfectedNodesInSubgraph[dsu.find(node)] == 1) {
                ans.emplace_back(-dsu.Rank[dsu.find(node)], node);
            }
        }
        sort(ans.begin(), ans.end());
        if (ans.empty()) return initial[0];
        else return ans.front().second;
    }
};

#ifdef LOCAL_MACHINE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    Solution obj;
}
#endif